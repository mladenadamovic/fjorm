# fjorm - Fast Java Object Relationship Mapping #

Performance testing of Hibernate (and many other available tools like JDO) suggests that Hibernate applications might be orders of magnitude slower than plain JDBC applications. polepos.org tests suggested in 2013 that Hibernate/MySQL, for example, is around 250% slower than MySQL/JDBC in their complex concurrency test [(reference)](http://polepos.sourceforge.net/results/PolePositionClientServer.pdf).

That is how **fjorm** is born, the author of fjorm have seen several projects which performance suffered deeply from using ORM. After analyzing Hibernate code (and some JDBC patterns) he wanted to make ORM better, especially efficient.

**fjorm** enables users to use relational databases, fast but simple object relationship mapping, without vendor lock-in (no cloud, but it is cloud ready).

## fjorm features: ##
  * designed to have less than 10% performance overhead over plain SQL
  * facilitate faster application development and cleaner code
  * no XML
  * simple to configure
  * test friendly (unit, integration, etc.)
  * no new query language (no JPQL, no HQL, no OQL, etc.)
  * no vendor lock-in (no cloud, but it is cloud ready)
  * using of standard SQL 'where' clause possible
  * CRUD ready, but does not support nested objects
  * designed by former Google software engineer
  * it is stable. It has been used by [Numbeo](http://www.numbeo.com), [Tralev](http://www.tralev.com), [Online-Utility](http://www.online-utility.org), [DecisionCrowd](http://www.decisioncrowd.com) etc.


## Example usages (from Tralev.com) ##

Please look at [Tralev](http://www.tralev.com) before you read this example to understand what the following code does.

Table image\_info represent information about image and table image\_vote stores votes from the user about the image:
```
create table image_info(
  id int auto_increment primary key,
  uploader_username varchar(255),
  uploader_website varchar (255),
  uploader_ip_add varchar(64),
  uploader_displayable_name varchar(255),
  lat double,
  lng double,
  popularity_score int default 0,
  popularity_entries int default 0,
  moderator_score int default 0,
  pageviews int default 0,
  went_to_map int default 0,
  width int default 0,
  height int default 0,
  timestmp timestamp default CURRENT_TIMESTAMP
)DEFAULT CHARACTER SET utf8;
CREATE INDEX image_info_idx on image_info(id, uploader_username, uploader_ip_add);

create table image_vote(
  id int auto_increment primary key,
  image_id int,
  vote int,
  username varchar(255),
  month int,
  year int,   
  FOREIGN KEY (image_id) REFERENCES image_info(id)
)DEFAULT CHARACTER SET utf8;
CREATE INDEX image_vote_image_idx on image_vote (image_id);
```

This is in Class for representing image\_info in Java:
```
@TableName(table = "image_info")
public class ImageInfo {

  @Id
  @AutoGenerated
  public int id;

  public String uploader_username;
  public String uploader_displayable_name;
  public String uploader_website;
  public String uploader_ip_add;
  public double lat;
  public double lng;
  public int popularity_score;
  public int popularity_entries;
  public int moderator_score;
  public int pageviews;
  public int went_to_map;
  public Timestamp timestmp = new Timestamp(new Date().getTime());
  
  @Transient
  public double distance_meters;

  public int width;
  public int height;

}
```

Table for storing info about images user did like:
```
@TableName(table = "image_vote")
public class ImageVote {
  @Id
  @AutoGenerated
  public int id;

  public int image_id;
  public int vote;
  public String username;
  public int month;
  public int year;
}

```

# Look at these examples to see how code with fjorm is much simpler than JDBC: #

### Creating new image\_info ###
```
  Dao<ImageInfo> imageInfoDao = Dao.<ImageInfo>getDao(ImageInfo.class, TralevDaoProperties.getInstance());
  newImageInfo = imageInfoDao.create(newImageInfo);
  if (newImageInfo.id > 0) {
    // ... code ommitted
  }
```

### Getting uploads from user ###
```
  List<ImageInfo> imagesFromUser = imageInfoDao.read(" where uploader_username = ? order by id desc limit 1000", email);
```

### Getting images near given coordinates (lat, lng) ###
```
  List<ImageInfo> imagesToReturn = imageInfoDao.read("where lat > ? and lat < ? and lng > ? and lng < ? limit 2000", 
       lat - 0.2, lat + 0.2, lng - 0.2, lng + 0.2);
  addDistancesToEachImageInfo(imagesToReturn, lat, lng);
  //smarly filter images according to distance and popularity
  Collections.sort(imagesToReturn, Collections.reverseOrder(new ImageInfoComparatorUsingPopularityAndDistance()));
```



### Getting pictures which user liked ###
```
  List<ImageInfo> imagesUserLiked = imageInfoDao.read(" inner join image_vote on image_info.id = image_vote.image_id " + 
              "where image_vote.username = ? and image_vote.vote = 1 order by image_vote.id desc limit 1000", email);
```

## More Documentation ##
Visit our [Wiki](https://code.google.com/p/fjorm/w/)

## Download ##
[Jar file](https://code.google.com/p/fjorm/source/browse/dist/fjorm.jar)